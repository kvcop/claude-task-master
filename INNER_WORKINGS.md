# Принципы работы `claude-task-master`

`claude-task-master` — это инструмент, предназначенный для помощи в управлении задачами проекта, особенно в контексте AI-ассистируемой разработки. Его основная идея заключается в использовании языковых моделей ИИ (преимущественно Claude от Anthropic, с возможностью подключения Perplexity для исследовательских задач) для автоматизации создания, декомпозиции и обновления задач.

## Ключевые автоматизируемые процессы с использованием ИИ:

Инструмент автоматизирует несколько ключевых этапов работы с задачами:

1.  **Создание задач из PRD (Product Requirements Document):**
    *   Пользователь предоставляет текстовый PRD.
    *   `claude-task-master` (команда `parse-prd`) отправляет этот текст ИИ вместе со специальным системным промптом.
    *   Системный промпт инструктирует ИИ проанализировать PRD, выделить основные этапы работ и представить их в виде структурированного JSON-списка задач. Промпт задает формат каждой задачи (поля: `id`, `title`, `description`, `details`, `testStrategy`, `status`, `priority`, `dependencies`).
    *   Результат (список задач в JSON) сохраняется в файл `tasks/tasks.json`.

2.  **Декомпозиция (расширение) задачи на подзадачи:**
    *   Пользователь выбирает существующую задачу для детализации (команда `expand-task`).
    *   `claude-task-master` отправляет ИИ описание этой задачи и запрос на ее разбиение на указанное количество подзадач.
    *   Используются системные промпты, которые направляют ИИ на генерацию логически связанных подзадач с соответствующими деталями. Существует возможность использовать "исследовательскую" роль ИИ (Perplexity) для более глубокой проработки или стандартную роль (Claude).
    *   Инструмент также может учитывать предварительный "анализ сложности" задачи, выполненный ИИ, который может рекомендовать оптимальное количество подзадач и специфичный промпт для их генерации.
    *   Сгенерированные подзадачи добавляются к родительской задаче в `tasks.json`.

3.  **Обновление существующей задачи:**
    *   Пользователь предоставляет ID задачи и текстовый промпт с описанием необходимых изменений (команда `update-task` или `update-task-by-id`).
    *   `claude-task-master` передает ИИ текущее состояние задачи (в формате JSON) и пользовательский промпт.
    *   Системный промпт для ИИ содержит строгие инструкции: обновить задачу на основе новой информации, но **не изменять ее заголовок (`title`) и ID**. Особое внимание уделяется **сохранению без изменений уже выполненных подзадач (`status: "done"` или `"completed"`)**. Если выполненную подзадачу нужно изменить, ИИ должен создать новую подзадачу, описывающую это изменение, а не модифицировать старую.
    *   Обновленная задача записывается обратно в `tasks.json`.

4.  **Анализ сложности задач:**
    *   Инструмент может проанализировать все задачи (команда `analyze-complexity`) с помощью ИИ.
    *   ИИ оценивает сложность каждой задачи и может предложить оптимальное количество подзадач для ее декомпозиции, а также кастомизированный промпт, который затем может быть использован командой `expand-task`.
    *   Результаты анализа сохраняются в отчет (`scripts/task-complexity-report.json`).

## Взаимодействие с ИИ:

*   **Промпт-инжиниринг:** Качество работы сильно зависит от тщательно составленных системных промптов, которые направляют ИИ на выполнение конкретной задачи в нужном формате. Эти промпты включают описание роли ИИ, ожидаемой структуры ответа (обычно JSON), требования к содержанию и ограничения.
*   **Обработка ответа:** Ответы от ИИ (текст или JSON) проходят через парсинг (иногда с попытками исправить незначительные ошибки формата) и валидацию (с использованием Zod-схем) перед тем, как данные будут сохранены.
*   **Модульность:** Логика взаимодействия с различными API ИИ инкапсулирована (предположительно в модуле `ai-services-unified.js`), что позволяет унифицировать вызовы к ним.

Таким образом, `claude-task-master` не просто хранит задачи, а активно использует ИИ для их семантической обработки и генерации, стремясь облегчить процесс планирования и актуализации проектных задач.

## Воспроизведение функциональности вручную с ИИ-ассистентом

Хотя `claude-task-master` автоматизирует многие шаги через специфичные API и промпты, основную суть его работы по генерации и уточнению задач можно воспроизвести вручную, используя универсального ИИ-ассистента (например, ChatGPT, Claude в веб-интерфейсе, или меня, Jules, если я интегрирован в вашу среду).

Ваша цель — не пользоваться платными API напрямую, а давать задачи ИИ-ассистенту, инструктируя его о том, где находится PRD, и какие действия нужно совершить.

### 1. Создание задач из PRD

Вместо `task-master parse-prd`:

1.  **Подготовка:**
    *   Убедитесь, что ваш PRD (Product Requirements Document) сохранен в текстовом формате (например, `prd.txt` или markdown).
    *   Определите, сколько примерно задач вы ожидаете получить.

2.  **Формулировка запроса ИИ-ассистенту:**

    ```text
    Привет! Мне нужно разбить Product Requirements Document (PRD) на список задач для разработки.
    Вот текст PRD:
    ---
    [ВСТАВЬТЕ СЮДА ПОЛНЫЙ ТЕКСТ ВАШЕГО PRD]
    ---

    Пожалуйста, проанализируй этот PRD и создай примерно [УКАЖИТЕ ЖЕЛАЕМОЕ КОЛИЧЕСТВО, например, 10-15] основных задач.
    Для каждой задачи предоставь следующую информацию:
    *   **title:** Краткий, емкий заголовок задачи.
    *   **description:** Описание того, что должна включать задача.
    *   **details:** Более подробные инструкции по реализации, возможные шаги или технические аспекты, если их можно извлечь из PRD или логически предположить.
    *   **testStrategy:** Как можно будет проверить, что задача выполнена корректно.
    *   **priority:** (high, medium, low) - оцени исходя из важности и последовательности.
    *   **dependencies:** (список ID других задач из этого же списка, если задача зависит от них). Постарайся определить логические зависимости.

    Присвой каждой задаче уникальный ID, начиная с 1.
    Представь результат в формате JSON-массива объектов, где каждый объект — это одна задача.

    Пример структуры для одной задачи:
    {
      "id": 1,
      "title": "Настройка окружения проекта",
      "description": "Создать репозиторий, настроить базовую структуру проекта, установить зависимости.",
      "details": "Использовать Node.js vXX, npm. Основные директории: src, tests, docs.",
      "testStrategy": "Запустить базовый 'hello world' скрипт, убедиться, что тесты проходят.",
      "priority": "high",
      "dependencies": []
    }

    Пожалуйста, будь внимателен к деталям в PRD и старайся сделать задачи логически последовательными.
    ```

3.  **Обработка результата:**
    *   ИИ-ассистент предоставит вам список задач (вероятно, в текстовом или JSON-формате).
    *   Просмотрите его, при необходимости скорректируйте.
    *   Вы можете сохранить это в `tasks.json` (если получили JSON) или разнести по отдельным файлам (например, `tasks/task_001.md`, `task_002.md`), где каждый файл описывает одну задачу.

### 2. Декомпозиция (расширение) задачи на подзадачи

Вместо `task-master expand-task`:

1.  **Подготовка:**
    *   Выберите задачу, которую хотите декомпозировать. У вас должно быть ее описание и детали.
    *   Определите, на сколько примерно подзадач вы хотите ее разбить.

2.  **Формулировка запроса ИИ-ассистенту:**

    ```text
    Мне нужно декомпозировать следующую задачу на [УКАЖИТЕ ЖЕЛАЕМОЕ КОЛИЧЕСТВО, например, 3-5] более мелких подзадач.

    Родительская задача:
    ID: [ID родительской задачи, например, 5]
    Title: [Заголовок родительской задачи]
    Description: [Описание родительской задачи]
    Details: [Детали родительской задачи, если есть]
    ---

    Для каждой подзадачи предоставь:
    *   **id:** Уникальный ID подзадачи (например, если родительская 5, то подзадачи 5.1, 5.2 или просто 1, 2, 3 в контексте этой декомпозиции – уточните, как вам удобнее).
    *   **title:** Краткий заголовок подзадачи.
    *   **description:** Описание подзадачи.
    *   **details:** Детали реализации для этой подзадачи.
    *   **dependencies:** (ID других подзадач из этого же набора, если есть зависимости между ними).
    *   **testStrategy:** Как проверить выполнение этой подзадачи.

    Присвой каждой подзадаче статус "pending".
    Постарайся сделать подзадачи логически последовательными и чтобы они полностью покрывали родительскую задачу.
    Представь результат в виде JSON-массива объектов подзадач.
    ```

3.  **Обработка результата:**
    *   Изучите предложенные подзадачи.
    *   Добавьте их к родительской задаче (например, в поле `subtasks` в вашем `tasks.json` или в соответствующий markdown-файл).

### 3. Обновление существующей задачи

Вместо `task-master update-task`:

1.  **Подготовка:**
    *   Определите задачу, которую нужно обновить.
    *   Сформулируйте, какие именно изменения нужно внести (например, "нужно использовать PostgreSQL вместо MongoDB", "добавить поддержку OAuth2").

2.  **Формулировка запроса ИИ-ассистенту:**

    ```text
    Мне нужно обновить существующую задачу на основе новой информации.

    Текущая задача:
    ---
    [ВСТАВЬТЕ СЮДА JSON ИЛИ ПОЛНОЕ ОПИСАНИЕ ТЕКУЩЕЙ ЗАДАЧИ, ВКЛЮЧАЯ ЕЕ ID, TITLE, DESCRIPTION, DETAILS, SUBTASKS И Т.Д.]
    ---

    Новая информация/требования для обновления:
    ---
    [ОПИШИТЕ ПОДРОБНО, ЧТО НУЖНО ИЗМЕНИТЬ. Например: "Внедрить аутентификацию через Google Sign-In. Это затронет детали реализации секции X и потребует добавления новой подзадачи для настройки Google Cloud Console. Существующая подзадача Y по базовой аутентификации должна быть отмечена как устаревшая или заменена."]
    ---

    Пожалуйста, предоставь обновленный JSON задачи.
    Ключевые моменты при обновлении:
    1.  **Не изменяй `title` и `id` родительской задачи.**
    2.  Обнови `description`, `details` и `testStrategy` родительской задачи, если это необходимо.
    3.  **Очень важно: Если у задачи есть подзадачи (`subtasks`) со статусом "done" или "completed", их нельзя изменять или удалять. Они должны остаться в том же виде.**
    4.  Если новая информация требует изменения логики, которая была реализована в уже выполненной подзадаче, создай новую подзадачу, которая описывает это изменение или замену, вместо модификации выполненной.
    5.  Добавь новые подзадачи, если это требуется для реализации новых требований.
    6.  Удали или измени существующие невыполненные подзадачи, если они становятся неактуальными.
    ```


3.  **Обработка результата:**
    *   Внимательно проверьте предложенный ИИ обновленный JSON задачи. Убедитесь, что все ваши условия (особенно по сохранению title и выполненных подзадач) соблюдены.
    *   Замените старую версию задачи на новую в вашем `tasks.json` или соответствующем файле.

### Организация файлов и статусов

После генерации или обновления задач сохраните полученный JSON в `tasks/tasks.json`. Если папка `tasks/` еще не создана, создайте ее и разложите каждую задачу по отдельным файлам (`task_001.txt`, `task_002.txt` и т.д.) в формате, описанном в `docs/task-structure.md`.
При выполнении или редактировании задач всегда обновляйте поле `status` и содержимое соответствующего файла. Следите, чтобы `tasks.json` и файлы в `tasks/` оставались синхронизированными.

### Общие советы при работе с ИИ-ассистентом для управления задачами:

*   **Контекст – это ключ:** Чем больше релевантной информации вы предоставите ИИ (текст PRD, описание существующей задачи, четкие инструкции), тем лучше будет результат.
*   **Итеративность:** Не ожидайте идеального результата с первого раза. Будьте готовы уточнять запросы, просить ИИ переделать часть работы или корректировать результат вручную.
*   **Четкие инструкции по формату:** Если вам нужен конкретный формат вывода (например, JSON с определенной структурой), явно укажите это в промпте и приведите пример.
*   **Разделяйте сложные запросы:** Если задача для ИИ слишком объемная (например, обработать огромный PRD и сразу выдать идеальную структуру на 100 задач), разбейте ее на части.
*   **Контроль зависимостей и статусов:** ИИ может помочь с первоначальным определением зависимостей, но вам (или другому инструменту) нужно будет отслеживать их выполнение и обновлять статусы задач.

Используя эти подходы, вы сможете вручную или с помощью универсального ИИ-ассистента выполнять многие функции `claude-task-master`, адаптируя процесс под ваши нужды и имеющиеся инструменты, без прямой зависимости от его специфических API.
